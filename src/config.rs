use base64::Engine; // <-- necesario para encode/decode en base64 0.22
use serde::{Deserialize, Serialize};
use std::{
    collections::BTreeMap,
    fs,
    io,
    path::{Path, PathBuf},
};

const KEY_UI_B64: &str = "JOB_HUNTER_UI_CONFIG_B64";
const KEY_OPENAI: &str = "OPENAI_API_KEY";
const KEY_ANTHROPIC: &str = "ANTHROPIC_API_KEY";

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct UiSourceCfg {
    pub enabled: bool,
    pub delay_ms: u64,
    pub user_agent: String,
    pub use_proxy: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UiConfig {
    pub keywords: String,
    pub experience: String,

    pub llm_provider: String, // "local" | "openai" | "anthropic"
    pub llm_use_case: String, // "fast" | "balanced" | "deep" | "long_context"

    pub openai_base_url: String,
    pub anthropic_base_url: String,

    pub cloud_model: String,    // "auto" or id
    pub local_endpoint: String, // http://localhost:11434
    pub local_model: String,    // llama3, etc.

    pub sources: BTreeMap<String, UiSourceCfg>,
}

impl Default for UiConfig {
    fn default() -> Self {
        let mut sources = BTreeMap::new();
        for id in ["remoteok", "wwr", "arbeitnow", "himalayas", "jobspresso"] {
            sources.insert(
                id.to_string(),
                UiSourceCfg {
                    enabled: id != "jobspresso",
                    delay_ms: 1200,
                    user_agent: "Mozilla/5.0".to_string(),
                    use_proxy: false,
                },
            );
        }

        Self {
            keywords: "rust, backend".to_string(),
            experience: "Any".to_string(),

            llm_provider: "local".to_string(),
            llm_use_case: "balanced".to_string(),

            openai_base_url: "https://api.openai.com".to_string(),
            anthropic_base_url: "https://api.anthropic.com".to_string(),

            cloud_model: "auto".to_string(),
            local_endpoint: "http://localhost:11434".to_string(),
            local_model: "llama3".to_string(),

            sources,
        }
    }
}

#[derive(Debug, Clone, Serialize)]
pub struct SecretsView {
    pub openai_api_key: Option<String>,
    pub anthropic_api_key: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
pub struct LoadedConfig {
    pub config: UiConfig,
    pub secrets: SecretsView,
}

#[derive(Debug, Clone, Deserialize)]
pub struct SaveConfigRequest {
    pub config: UiConfig,
    pub save_secrets: bool,
    pub openai_api_key: Option<String>,
    pub anthropic_api_key: Option<String>,
}

fn strip_quotes(s: &str) -> String {
    let t = s.trim();
    if (t.starts_with('"') && t.ends_with('"')) || (t.starts_with('\'') && t.ends_with('\'')) {
        t[1..t.len().saturating_sub(1)].to_string()
    } else {
        t.to_string()
    }
}

fn parse_env_file(path: &Path) -> BTreeMap<String, String> {
    let mut map = BTreeMap::new();
    let Ok(content) = fs::read_to_string(path) else { return map; };

    for line in content.lines() {
        let l = line.trim();
        if l.is_empty() || l.starts_with('#') {
            continue;
        }
        let Some((k, v)) = l.split_once('=') else { continue; };
        map.insert(k.trim().to_string(), strip_quotes(v));
    }
    map
}

fn write_env_file(path: &Path, map: &BTreeMap<String, String>) -> io::Result<()> {
    let mut out = String::new();
    out.push_str("# Auto-generated by Job Hunter UI (edit with care)\n");
    for (k, v) in map {
        out.push_str(&format!("{k}={v}\n"));
    }
    fs::write(path, out)
}

fn b64_encode_json<T: Serialize>(v: &T) -> Result<String, String> {
    let json = serde_json::to_string(v).map_err(|e| e.to_string())?;
    Ok(base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(json.as_bytes()))
}

fn b64_decode_json<T: for<'de> Deserialize<'de>>(b64: &str) -> Result<T, String> {
    let bytes = base64::engine::general_purpose::URL_SAFE_NO_PAD
        .decode(b64.as_bytes())
        .map_err(|e| e.to_string())?;
    let v: T = serde_json::from_slice(&bytes).map_err(|e| e.to_string())?;
    Ok(v)
}

fn mask_secret(s: &str) -> String {
    let t = s.trim();
    if t.len() <= 8 {
        return "********".to_string();
    }
    let tail = &t[t.len() - 4..];
    format!("****{}", tail)
}

pub fn env_path_from_env() -> PathBuf {
    std::env::var("JOB_HUNTER_ENV_FILE")
        .map(PathBuf::from)
        .unwrap_or_else(|_| PathBuf::from(".env"))
}

pub fn web_dir_from_env() -> String {
    std::env::var("JOB_HUNTER_WEB_DIR").unwrap_or_else(|_| "web".to_string())
}

pub fn load_config(env_path: &Path, include_secrets: bool) -> LoadedConfig {
    let env = parse_env_file(env_path);

    let config = env
        .get(KEY_UI_B64)
        .and_then(|b64| b64_decode_json::<UiConfig>(b64).ok())
        .unwrap_or_default();

    let openai = env.get(KEY_OPENAI).cloned();
    let anthropic = env.get(KEY_ANTHROPIC).cloned();

    let secrets = if include_secrets {
        SecretsView {
            openai_api_key: openai,
            anthropic_api_key: anthropic,
        }
    } else {
        SecretsView {
            openai_api_key: openai.as_deref().map(mask_secret),
            anthropic_api_key: anthropic.as_deref().map(mask_secret),
        }
    };

    LoadedConfig { config, secrets }
}

pub fn save_config(env_path: &Path, req: SaveConfigRequest) -> Result<(), String> {
    let mut env = parse_env_file(env_path);

    let b64 = b64_encode_json(&req.config)?;
    env.insert(KEY_UI_B64.to_string(), b64);

    if req.save_secrets {
        if let Some(k) = req.openai_api_key {
            if !k.trim().is_empty() {
                env.insert(KEY_OPENAI.to_string(), k.trim().to_string());
            }
        }
        if let Some(k) = req.anthropic_api_key {
            if !k.trim().is_empty() {
                env.insert(KEY_ANTHROPIC.to_string(), k.trim().to_string());
            }
        }
    } else {
        env.remove(KEY_OPENAI);
        env.remove(KEY_ANTHROPIC);
    }

    write_env_file(env_path, &env).map_err(|e| e.to_string())
}

